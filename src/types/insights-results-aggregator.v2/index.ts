/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/ack': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Lists acks from this account where the rule is active
     * @description Lists acks from this account where the rule is active. Will return empty list if this account has no acks
     */
    get: operations['AckListEndpoint'];
    put?: never;
    /**
     * Acknowledges/hide the rule for given account
     * @description Acknowledges (and therefore hides) a rule from view in an account. If there's already an acknowledgement of this rule by this account, then return that. Othervise, a new ack is created.
     */
    post: operations['ackRuleSystemWide'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ack/{rule_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * AckGetEndpoint read the acknowledgement info about disabled rule
     * @description AckGetEndpoint read the acknowledgement info about disabled rule
     */
    get: operations['getAckRuleSystemWide'];
    /**
     * Updates an acknowledgement for a rule, by rule ID.
     * @description Updates an acknowledgement for a rule, by rule ID. A new justification can be supplied.
     */
    put: operations['UpdateAckRuleSystemWide'];
    post?: never;
    /**
     * Deletes an acknowledgement for a rule
     * @description Deletes an acknowledgement for a rule, by its rule ID. If the ack existed, it is deleted and a 204 is returned. Otherwise, a 404 is returned.
     */
    delete: operations['deleteAckRuleSystemWide'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/{clusterId}/info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns relevant information about the cluster available in AMS API.
     * @description Cluster ID is given in URL. Organization ID in token must match the one under which the cluster is registered in AMS.
     */
    get: operations['getInfoForCluster'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/{clusterId}/reports': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns the latest report for the given cluster.
     * @description Report that is going to be returned is specified by its cluster IDs that is part of path.
     */
    get: operations['getReportsForCluster'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/{clusterId}/request/{requestId}/report': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve simplified reports for a given cluster and request IDs if available
     * @description For the given cluster and request IDs, return the simplified report, if any. Response should have the following format:
     *     ```
     *     {
     *     "cluster": "{clusterID}",
     *     "requestID": "{requestID}",
     *     "status": "{string}",
     *     "report": "{simplifiedReportStructure}",
     *     }```
     *     Where simplifiedReportStructure might look like:
     *     ```[
     *     "rule_fqdn": "",
     *     "error_key": "",
     *     "description": "",
     *     "total_risk": "",
     *     ]
     *     ```
     *
     */
    get: operations['getReportForRequest'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/{clusterId}/request/{requestId}/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Check status of a given cluster's request
     * @description The status of the request with given ID if found. The cluster ID is required so only requests for the given cluster are returned, if any. Response should have the following format: ```
     *     {
     *     "cluster": "{clusterID}",
     *     "requestID":"{requestID}",
     *     "status": "{string}"
     *     }
     *     ```
     */
    get: operations['getRequestStatusForCluster'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/{clusterId}/requests': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of requests for given cluster
     * @description Provides a list of all the recorded requests for the cluster with given ID, if any. Response should have following format:
     *     ```{
     *     "cluster":"{clusterID}",
     *     "requests":[{array}],
     *     "status":"{string}"
     *     }
     *     ```
     *     Where {array} contains following objects:
     *     ```{
     *     "requestID": {requestID},
     *     "valid: True,
     *     "received": {timestamp},
     *     "processed": {timestamp},
     *     }
     *     ```
     */
    get: operations['getRequestsForCluster'];
    put?: never;
    /**
     * Filtered list of stored requests for given cluster ID
     * @description A list of requests for given cluster, filtered by the provided request IDs, if any. List of request IDs should be in format
     *     ```[
     *     "requestID1",
     *     "requestID2",
     *      ...,"requestID3"
     *     ]
     *     ```
     *     Response is in format:
     *     ```{
     *     "cluster": "{clusterID}"
     *     "requests": [{array}]
     *     "status": "{string}"
     *     }
     *     ```
     *     Where {array} contains the following objects:
     *     ```{
     *     "requestID": {requestID},
     *     "valid": true/false depends if this is valid/known request ID,
     *     "received": {timestamp},
     *     "processed": {timestamp},
     *     }
     *     ```
     *
     */
    post: operations['getRequestsForClusterPostVariant'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/{clusterId}/upgrade-risks-prediction': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a prediction of whether a cluster upgrade would fail. */
    get: operations['getUpgradeRisksPrediction'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/clusters': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns a list of clusters, total number of hitting rules and a count of impacting rules by total risk.
     * @description Retrieves all clusters for given organization, retrieves the impacting rules for each cluster and calculates the count of impacting rules by total risk (severity == critical, high, moderate, low)
     */
    get: operations['getClusters'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/content': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all static content
     * @description The static content is taken from the cache periodically updated from the content service
     */
    get: operations['getContent'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all rule groups and their relevant information
     * @description This simply redirects to an endpoint of the same name of a service called insights-content-service
     */
    get: operations['getRuleGroups'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns basic information about Smart Proxy, Insights Results Aggregator, and Content Service.
     * @description InfoEndpoint returns basic information about Smart Proxy, Insights Results Aggregator, and Content Service version, utils repository version, commit hash etc.
     */
    get: operations['InfoEndpoint'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read all metrics exposed by this service
     * @description Set of metrics provided by insights-operator-utils library providing total number of requests counter, API endpoints response times, and counter of HTTP status code responses. Additionally it is possible to consume all metrics provided by Go runtime. These metrics start with go_ and process_ prefixes.
     */
    get: operations['getMetrics'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/dvo': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve DVO namespaces and recommendation aggregations for the whole organization
     * @description For the user's organization, return a list of namespaces and aggregate information about each namespace
     */
    get: operations['getDVONamespaces'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/dvo/{namespaceId}/cluster/{clusterId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve DVO recommendations for a single namespace + cluster combination.
     * @description For the given cluster and namespace IDs, return a list of DVO recommendations, complete with the descriptions and steps to resolve.
     */
    get: operations['getDVONamespaceCluster'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/openapi.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns the OpenAPI specification JSON.
     * @description The OpenAPI specification of this REST API service that is represented in formatted and human-readable JSON is available under this endpoint.
     */
    get: operations['getOpenApi'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/rating': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send the new rating for a given rule
     * @description Return the new rating. Any previous rating for this rule by this user is amended to the current value. This does not attempt to delete a rating by this user of thus rule if the rating is zero.
     */
    post: operations['sendRating'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/rule': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns a list recommendations and the number of clusters they're currently impacting.
     * @description The affected clusters are based on the requester's organization. If the AMS API is available, the clusters are pulled from there, otherwise we retrieve the clusters from our database.
     */
    get: operations['getRecommendations'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/rule/{ruleId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get content for the given ruleId, along with user-specific data such as rule rating, disabling, etc.
     * @description The static content is taken from the cache periodically updated from the content service. The user specific parts need trips to the aggregator service.
     */
    get: operations['getContentAndGroupsForRule'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/rule/{ruleId}/content': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all static content for the given ruleId.
     * @description The static content is taken from the cache periodically updated from the content service.
     */
    get: operations['getContentForRule'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/rule/{rule_selector}/clusters_detail': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns a list of cluster where the given rule is active. Also returns a list of clusters, for which the rule has been disabled.
     * @description Provided a correct rule selector and a valid organization ID, this method will query the DB for all the organization's clusters being currently affected by the rule, if any.
     */
    get: operations['getClustersForRecommendation'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/upgrade-risks-prediction': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Returns the prediction based on latest stats for the given list of clusters.
     * @description Predictions that are going to be returned are specified by list of cluster IDs that is part of request body.
     */
    post: operations['getUpgradeRisksPredictionForClustersPost'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    alert: {
      /** @example SomeCriticalAlert */
      name: string;
      /** @example openshift-kube-apiserver */
      namespace: string;
      /** @example critical */
      severity: string;
      /** @example https://some_url.com/monitoring/alerts?orderBy=asc&sortBy=Severity&alert-name=SomeCriticalAlert */
      url: string;
    };
    /**
     * Format: uuid
     * @description ID of the cluster in valid UUID format
     */
    clusterId: string;
    clusterList: {
      /** Format: uuid */
      cluster_id?: string;
      /**
       * @description An human-readable name for the cluster
       * @example Production cluster 1
       */
      cluster_name?: string;
      /**
       * @description [Optional] Cluster version
       * @example 4.7
       */
      cluster_version?: string;
      /**
       * @description Dictionary with numeric representation of total risk as keys, the number of rule hits by each total risk as values.
       * @example {
       *       "1": 1,
       *       "2": 4,
       *       "3": 0,
       *       "4": 0
       *     }
       */
      hits_by_total_risk?: unknown;
      /**
       * Format: date-time
       * @description [Optional] Last time of analysis for given cluster.
       */
      last_checked_at?: string;
      /** @description Total number of rules hitting for given cluster. 0 combined with an empty last_checked_at means we haven't received any archive from that cluster. 0 hits with a valid timestamp means we have an archive, but there are no rule hits. */
      total_hit_count?: number;
    }[];
    /** @description Response data type for GET /clusters endpoint */
    clusterListResponse: {
      data?: components['schemas']['clusterList'];
      meta?: {
        /** Format: int32 */
        count?: number;
      };
      /** @description Request response status */
      status?: string;
    };
    dvoReportMeta: {
      /** @description Highest recommendation severity affecting this namespace + cluster */
      highest_severity?: number;
      /**
       * @description A dictionary with the number of DVO recommendation hits grouped by their severity. Always provides the severity keys even if there are no recommendations currently hitting.
       * @example {
       *       "1": 2,
       *       "2": 3,
       *       "3": 0,
       *       "4": 1
       *     }
       */
      hits_by_severity?: {
        [key: string]: number;
      };
      /**
       * Format: date-time
       * @description Timestamp of the last analysis
       */
      last_checked_at?: string;
      /** @description Total number of unique objects (workloads) being affected by DVO recommendations in this namespace. When a workload is being affected by several recommendations at once, it still counts as one affected object/workload in the context of a namespace. */
      objects?: number;
      /** @description Total number of DVO recommendations affecting this namespace */
      recommendations?: number;
      /**
       * Format: date-time
       * @description Timestamp of the first analysis
       */
      reported_at?: string;
    };
    /** @description List of stored requests for given orgId + clusterId */
    gatheringRequests: {
      /** Format: RFC339Nano */
      processed: string;
      /** Format: RFC339Nano */
      received: string;
      requestID: components['schemas']['requestId'];
      valid: boolean;
    }[];
    /**
     * Format: uuid
     * @description ID of the namespace in a valid UUID format
     */
    namespaceId: string;
    operator_condition: {
      /** @example Degraded */
      condition: string;
      /** @example authentication */
      name: string;
      /** @example AsExpected */
      reason: string;
      /** @example https://some_url.com/k8s/cluster/config.openshift.io~v1~ClusterOperator/authentication */
      url: string;
    };
    ratingSchema: {
      rating?: number;
      rule?: string;
    };
    recommendationList: {
      /** @description The title of the rule, a short description. */
      description?: string;
      /**
       * @description Whether the rule has been disabled/acked for all clusters or not.
       * @example true
       */
      disabled?: boolean;
      /** @description More specific, cluster-independent description of the rule */
      generic?: string;
      /**
       * @description How much of an impact this rule has on a cluster.
       * @enum {integer}
       */
      impact?: RecommendationListImpact;
      /**
       * @description The number of clusters impacted by this rule. Disabled clusters are excluded from the count. If the rule is acked, it is just marked as disabled:true and the count is still returned.
       * @example 42
       */
      impacted_clusters_count?: number;
      /**
       * @description How likely is this rule to hit.
       * @enum {integer}
       */
      likelihood?: RecommendationListLikelihood;
      /**
       * Format: date-time
       * @description The date the rule was published. 'Added at' field in UI
       */
      publish_date?: string;
      /**
       * @description Indicates the impact of the resolution steps on the cluster and other associated risks. Behaves in the same way as total_risk, 0 is returned when the rule doesn't have a resolution_risk defined.
       * @enum {integer}
       */
      resolution_risk?: RecommendationListResolution_risk;
      /**
       * @description The rule ID in the | format.
       * @example rule.module|ERROR_KEY
       */
      rule_id?: string;
      /** @description List of tags that the rule contains */
      tags?: string[];
      /**
       * @description Total risk - calculated from rule impact and likelihood.
       * @enum {integer}
       */
      total_risk?: RecommendationListTotal_risk;
    }[];
    /** @description Response data type for GET /rule endpoint */
    recommendationListResponse: {
      recommendations?: components['schemas']['recommendationList'];
      /** @description Request response status */
      status?: string;
    };
    report: {
      data?: components['schemas']['reportData'][];
      meta?: components['schemas']['reportMeta'];
    };
    /**
     * @description /clusters/{clusterId}/report returns an array of ruleHit instances
     * @example {
     *       "created_at": "2020-04-08T00:42:00Z",
     *       "description": "Introducing Insights for Red Hat OpenShift Container Platform",
     *       "details": "Red Hat Insights for OpenShift is a proactive management solution. It provides ongoing infrastructure analyses of your Red Hat OpenShift Container Platform 4.2 and later installations. Red Hat Insights helps you identify, prioritize, and resolve risks to security, performance, availability, and stability before they become urgent issues.\nRed Hat Insights for OpenShift uses the Remote Health Monitoring feature of OpenShift 4. The health checks are created by Red Hat subject matter experts and assessed according to severity and impact.\nThis is an example  recommendation that you can safely ignore. To disable it, click  the triple-dot menu button next to the header, and select Disable.\n\n[Knowledgebase Article](https://access.redhat.com/search/#/knowledgebase)\n\n",
     *       "disable_feedback": "",
     *       "disabled": false,
     *       "disabled_at": "",
     *       "extra_data": {
     *         "error_key": "TUTORIAL_ERROR",
     *         "type": "rule"
     *       },
     *       "internal": false,
     *       "reason": "",
     *       "resolution": "",
     *       "rule_id": "ccx_rules_ocm.tutorial_rule.report",
     *       "tags": [
     *         "openshift",
     *         "service_availability"
     *       ],
     *       "total_risk": 1,
     *       "user_vote": 0
     *     }
     */
    reportData: {
      /** Format: date-time */
      created_at?: string;
      /** @description The title of the rule, a short description. */
      description?: string;
      /** @description Details of the rule - templates rendered on frontend. */
      details?: string;
      disable_feedback?: string;
      /** @description If this rule result disabled or not. This field can be used in the UI to show only specific set of rules results. */
      disabled?: boolean;
      disabled_at?: string;
      /** @description Used as templating data for other content (details, resolution, etc.), has varying structure depending on the rules in the report. */
      extra_data?: Record<string, never>;
      /**
       * Format: date-time
       * @description [Optional] Timestamp when the rule first started hitting
       */
      impacted?: string;
      internal?: boolean;
      /** @description Non essential information. */
      more_info?: string;
      /** @description Reason for the issue, giving the user more accurate description of the cause. */
      reason?: string;
      /** @description Resolution steps of the issue, possibly linking to a resolution article in the knowledge base. */
      resolution?: string;
      /** @description ID of a rule. */
      rule_id?: string;
      /** @description List of tags that the rule contains, forming rule groups. */
      tags?: string[];
      /**
       * @description Total risk - calculated from rule impact and likelihood.
       * @enum {integer}
       */
      total_risk?: ReportDataTotal_risk;
      /**
       * Format: int32
       * @description User vote - value of user voting. -1 is dislike vote, 0 is no vote, 1 is like vote.
       * @enum {integer}
       */
      user_vote?: ReportDataUser_vote;
    };
    /** @example {
     *       "count": 9,
     *       "last_checked_at": "2020-12-08T09:45:23Z",
     *       "managed": false
     *     } */
    reportMeta: {
      /** @description The display name of the cluster */
      cluster_name?: string;
      /** Format: int32 */
      count?: number;
      /** Format: date-time */
      gathered_at?: string;
      /**
       * Format: date-time
       * @description [Optional] Timestamp of the last analysis
       */
      last_checked_at?: string;
      /** @description Flag indicating if the cluster is managed or not */
      managed?: boolean;
    };
    /** @description Response data type for GET /clusters/{clusterId}/report endpoint */
    reportResponse: {
      report?: components['schemas']['report'];
      status?: string;
    };
    /**
     * Format: x-rh-insights-request-id
     * @description request ID
     * @example 6d2eede257644308a8949c4ec251c5c4
     */
    requestId: string;
    simplifiedReport: {
      description: string;
      error_key: string;
      rule_fqdn: string;
      total_risk: number;
    }[];
    /**
     * @description response status for the processed request
     * @example ok
     */
    statusResponse: string;
    /** @description An information about rule that has been disabled for whole account */
    systemWideRuleDisable: {
      /**
       * Format: date-time
       * @description Timestamp when the rule has been acked/disabled
       * @example 2021-09-05T16:29:33+02:00
       */
      created_at?: string;
      /**
       * @description ID of user (account)
       * @example 42
       */
      created_by?: string;
      /**
       * @description Justification (message) provided by user
       * @example I don't like this rule!
       */
      justification?: string;
      /**
       * @description Rule selector: rule ID + error key
       * @example foo.bar|baz
       */
      rule?: string;
      /**
       * @description Timestamp when the rule justification has been changed (can be empty)
       * @default
       * @example 2021-09-05T16:29:33+02:00
       */
      updated_at: string;
    };
    /** @description List of all system-wide disabled rules */
    systemWideRuleDisableList: {
      data?: {
        /** Format: date-time */
        created_at?: string;
        created_by?: string;
        justification?: string;
        rule?: string;
        updated_at?: string | unknown | unknown;
      }[];
      meta?: {
        /** Format: int32 */
        count?: number;
      };
    };
    upgradeRisksPrediction: {
      /** @example aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee */
      cluster_id: string;
      /**
       * Format: date-time
       * @example 2011-15-04T00:05:23Z
       */
      last_checked_at?: string;
      /** @example ok */
      prediction_status: string;
      /** @example true */
      upgrade_recommended?: boolean;
      upgrade_risks_predictors?: components['schemas']['upgradeRisksPredictors'];
    };
    upgradeRisksPredictors: {
      alerts: components['schemas']['alert'][];
      operator_conditions: components['schemas']['operator_condition'][];
    };
  };
  responses: never;
  parameters: {
    /**
     * @description ID of the rule for which content is required.
     * @example some.python.module|ERROR_KEY_NAME
     */
    ruleId: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type Alert = components['schemas']['alert'];
export type ClusterId = components['schemas']['clusterId'];
export type ClusterList = components['schemas']['clusterList'];
export type ClusterListResponse = components['schemas']['clusterListResponse'];
export type DvoReportMeta = components['schemas']['dvoReportMeta'];
export type GatheringRequests = components['schemas']['gatheringRequests'];
export type NamespaceId = components['schemas']['namespaceId'];
export type OperatorCondition = components['schemas']['operator_condition'];
export type RatingSchema = components['schemas']['ratingSchema'];
export type RecommendationList = components['schemas']['recommendationList'];
export type RecommendationListResponse = components['schemas']['recommendationListResponse'];
export type Report = components['schemas']['report'];
export type ReportData = components['schemas']['reportData'];
export type ReportMeta = components['schemas']['reportMeta'];
export type ReportResponse = components['schemas']['reportResponse'];
export type RequestId = components['schemas']['requestId'];
export type SimplifiedReport = components['schemas']['simplifiedReport'];
export type StatusResponse = components['schemas']['statusResponse'];
export type SystemWideRuleDisable = components['schemas']['systemWideRuleDisable'];
export type SystemWideRuleDisableList = components['schemas']['systemWideRuleDisableList'];
export type UpgradeRisksPrediction = components['schemas']['upgradeRisksPrediction'];
export type UpgradeRisksPredictors = components['schemas']['upgradeRisksPredictors'];
export type ParameterRuleId = components['parameters']['ruleId'];
export type $defs = Record<string, never>;
export interface operations {
  AckListEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of acked rules */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['systemWideRuleDisableList'];
        };
      };
    };
  };
  ackRuleSystemWide: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Specification of rule selector (ID+error key) and a justification why rule has been disabled. */
    requestBody: {
      content: {
        'application/json': {
          justification?: string;
          rule_id?: string;
        };
      };
    };
    responses: {
      /** @description Rule has been disabled already */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['systemWideRuleDisable'];
        };
      };
      /** @description Rule has been acked (disabled) */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['systemWideRuleDisable'];
        };
      };
    };
  };
  getAckRuleSystemWide: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specification of rule selector (ID+error key) and a justification why rule has been disabled. */
        rule_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Rule ack has been found, the metadata is returned in response body */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['systemWideRuleDisable'];
        };
      };
      /** @description Rule has not been acked (disabled) previously */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateAckRuleSystemWide: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specification of rule selector (ID+error key). */
        rule_id: string;
      };
      cookie?: never;
    };
    /** @description Specification of justification why rule has been disabled. */
    requestBody: {
      content: {
        'application/json': {
          justification?: string;
        };
      };
    };
    responses: {
      /** @description Rule ack has been found and updated, the metadata is returned in response body */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['systemWideRuleDisable'];
        };
      };
      /** @description Rule has not been acked (disabled) previously */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteAckRuleSystemWide: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specification of rule selector (ID+error key) and a justification why rule has been disabled. */
        rule_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Rule ack has been deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rule has not been acked (disabled) previously */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getInfoForCluster: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @example 34c3ecc5-624a-49a5-bab8-4fdc5e51a266 */
        clusterId: components['schemas']['clusterId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Information about the given cluster retrieved from AMS API. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            cluster?: {
              cluster_id?: components['schemas']['clusterId'];
              /**
               * @description An human-readable name for the cluster
               * @example Production cluster 1
               */
              display_name?: string;
              /**
               * @description Indicates whether cluster is managed or not (has 'managed' flag in AMS)
               * @example true
               */
              managed?: boolean;
              /**
               * @description Status of the cluster, such as Active, Deprovisioned, etc
               * @example Active
               */
              status?: string;
            };
            status?: components['schemas']['statusResponse'];
          };
        };
      };
      /** @description Invalid request, usually caused when some cluster belongs to different organization. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cluster info was not returned from AMS API for given organization. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getReportsForCluster: {
    parameters: {
      query?: {
        /** @description If true, disabled rules will be sent too. */
        get_disabled?: boolean;
      };
      header?: never;
      path: {
        /** @example 34c3ecc5-624a-49a5-bab8-4fdc5e51a266 */
        clusterId: components['schemas']['clusterId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Latest available report for the given organization and cluster combination. Returns rules and their descriptions that were hit by the cluster. Disabled rules are omitted by default unless the get_disabled query param is provided. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['reportResponse'];
        };
      };
      /** @description Invalid request, usually caused when some cluster belongs to different organization. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cluster report is not available, probably not connected cluster. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getReportForRequest: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        clusterId: components['schemas']['clusterId'];
        requestId: components['schemas']['requestId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Simplified report for given cluster and request IDs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            cluster: components['schemas']['clusterId'];
            report: components['schemas']['simplifiedReport'];
            requestID: components['schemas']['requestId'];
            status: components['schemas']['statusResponse'];
          };
        };
      };
      /** @description Invalid request or invalid cluster ID */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cluster or request ID not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRequestStatusForCluster: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        clusterId: components['schemas']['clusterId'];
        /** @description Request ID */
        requestId: components['schemas']['requestId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Stored status for the given cluster and request IDs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            cluster: components['schemas']['clusterId'];
            requestID: components['schemas']['requestId'];
            status: components['schemas']['statusResponse'];
          };
        };
      };
      /** @description Invalid request or invalid cluster ID */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Request ID or cluster ID not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRequestsForCluster: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @example 34c3ecc5-624a-49a5-bab8-4fdc5e51a266 */
        clusterId: components['schemas']['clusterId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of requests available (last 24 hours) for the given organization and cluster and their status. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            cluster: components['schemas']['clusterId'];
            requests: components['schemas']['gatheringRequests'];
            status: components['schemas']['statusResponse'];
          };
        };
      };
      /** @description Invalid request (e.g cluster ID with unexpected format) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cluster not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRequestsForClusterPostVariant: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        clusterId: components['schemas']['clusterId'];
      };
      cookie?: never;
    };
    /** @description List of request IDs */
    requestBody: {
      content: {
        'application/json': components['schemas']['requestId'][];
      };
    };
    responses: {
      /** @description List of requests available (last 24 hours) for the given organization and cluster and their status. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            cluster: components['schemas']['clusterId'];
            requests: components['schemas']['gatheringRequests'];
            status: components['schemas']['statusResponse'];
          };
        };
      };
      /** @description Invalid request (e.g cluster ID with unexpected format) or payload (empty body or not a list of strings) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cluster ID not found or no requests found in storage for provided IDs */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getUpgradeRisksPrediction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        clusterId: components['schemas']['clusterId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Status ok */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            meta?: {
              /**
               * Format: date-time
               * @description [Optional] Last time of analysis for given cluster.
               */
              last_checked_at?: string;
            };
            status?: components['schemas']['statusResponse'];
            upgrade_recommendation?: {
              upgrade_recommended?: boolean;
              upgrade_risks_predictors?: components['schemas']['upgradeRisksPredictors'];
            };
          };
        };
      };
      /** @description Status NoContent: happens when the cluster is managed. The upgrade risks prediction is not available for this kind of clusters. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Status NotFound: happens when the cluster cannot be found in the Observatorium data */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Status NotAvailable: happens when the AMS API or the Upgrade Risks Prediction service is not available. */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getClusters: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description If a cluster has 0 total_hit_count and empty last_checked_at timestamp, we have no Insights data for that archive. If total_hit_count = 0 and the timestamp is valid, there are no rule hits for the cluster. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['clusterListResponse'];
        };
      };
      /** @description A dependent service such as AMS API or results aggregator is unavailable. Specified in status message. */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            status?: string;
          };
        };
      };
    };
  };
  getContent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A JSON object with the content. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            content?: {
              HasReason?: boolean;
              error_keys?: {
                [key: string]: {
                  HasReason?: boolean;
                  generic?: string;
                  metadata?: {
                    description?: string;
                    impact?: string;
                    /** @enum {integer} */
                    likelihood?: PathsContentGetResponses200ContentApplicationJsonContentError_keysMetadataLikelihood;
                    publish_date?: string;
                    status?: string;
                    tags?: string[] | null;
                  };
                  more_info?: string;
                  reason?: string;
                  resolution?: string;
                  summary?: string;
                  /** @enum {integer} */
                  total_risk?: PathsContentGetResponses200ContentApplicationJsonContentError_keysTotal_risk;
                };
              };
              generic?: string;
              more_info?: string;
              plugin?: {
                name?: string;
                node_id?: string;
                product_code?: string;
                python_module?: string;
              };
              reason?: string;
              resolution?: string;
              summary?: string;
            }[];
            groups?: {
              description?: string;
              tags?: string[];
              title?: string;
            }[];
            status?: components['schemas']['statusResponse'];
          };
        };
      };
    };
  };
  getRuleGroups: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A JSON array of groups. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            groups?: {
              description?: string;
              tags?: string[];
              title?: string;
            }[];
            /** @example ok */
            status?: string;
          };
        };
      };
      /** @description Content service is unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/plain': unknown;
        };
      };
    };
  };
  InfoEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An object containing information about Smart Proxy, Insights Results Aggregator, and Content Service. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            info?: {
              Aggregator?: {
                [key: string]: string;
              };
              ContentService?: {
                [key: string]: string;
              };
              SmartProxy?: {
                [key: string]: string;
              };
            };
            status?: components['schemas']['statusResponse'];
          };
        };
      };
    };
  };
  getMetrics: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Default response containing all metrics in semi-structured text format */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/plain': unknown;
        };
      };
    };
  };
  getDVONamespaces: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Namespaces for DVO workloads */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            status: components['schemas']['statusResponse'];
            /** @description A list of namespaces, aggregate data about their workloads and DVO recommendations. Returns an empty list when a cluster is known, but no recommendations were found. */
            workloads: {
              cluster?: {
                /**
                 * @description A human-readable name for the cluster
                 * @example Production cluster 1
                 */
                display_name?: string;
                uuid?: components['schemas']['clusterId'];
              };
              metadata?: components['schemas']['dvoReportMeta'];
              namespace?: {
                /**
                 * @description A human-readable name for the namespace
                 * @example Production namespace 1
                 */
                name?: string;
                uuid?: components['schemas']['namespaceId'];
              };
              status?: components['schemas']['statusResponse'];
            }[];
          };
        };
      };
      /** @description Invalid request or invalid cluster ID */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cluster was not found in the AMS API. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDVONamespaceCluster: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        clusterId: components['schemas']['clusterId'];
        namespaceId: components['schemas']['requestId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DVO recommendations for namespace + cluster */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            cluster: {
              /**
               * @description A human-readable name for the cluster
               * @example Production cluster 1
               */
              display_name?: string;
              uuid?: components['schemas']['clusterId'];
            };
            metadata: components['schemas']['dvoReportMeta'];
            namespace: {
              /**
               * @description A human-readable name for the namespace
               * @example Production namespace 1
               */
              name?: string;
              uuid?: components['schemas']['namespaceId'];
            };
            recommendations: {
              /**
               * @description The rule ID in the | format.
               * @example rule.module|ERROR_KEY
               */
              check?: string;
              /** @description The title of the rule, a short description. */
              details?: string;
              /** @description Used as templating/interpolation data for other content (details, resolution, etc.), has varying structure depending on the rules in the report, but should always be a valid JSON object. */
              extra_data?: Record<string, never>;
              /**
               * Format: date-time
               * @description The date the recommendation was last updated.
               */
              modified?: string;
              /** @description Additional information regarding the recommendation. */
              more_info?: string;
              objects?: {
                /**
                 * @description A human-readable name for the cluster
                 * @example Production cluster 1
                 */
                display_name?: string;
                /** @description The kind/category of the object. */
                kind?: string;
                /** @description ID of the object. */
                uid?: string;
              }[];
              /** @description Reason for the issue, giving the user more accurate description of the cause. */
              reason?: string;
              /** @description Resolution steps of the issue, possibly linking to a resolution article in the knowledge base. */
              resolution?: string;
              /**
               * @description Total risk - calculated from rule impact and likelihood.
               * @enum {integer}
               */
              total_risk?: PathsNamespacesDvoNamespaceIdClusterClusterIdGetResponses200ContentApplicationJsonRecommendationsTotal_risk;
            }[];
            status: components['schemas']['statusResponse'];
          };
        };
      };
      /** @description Invalid request or invalid cluster ID */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Data for cluster and namespace were not found in the storage. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getOpenApi: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A JSON containing the OpenAPI specification for this service. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            components?: Record<string, never>;
            info?: {
              description?: string;
              title?: string;
              version?: string;
            };
            openapi?: string;
            /** @description Available paths and their descriptions. */
            paths?: Record<string, never>;
          };
        };
      };
    };
  };
  sendRating: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description A JSON object with the current rule and its rating. */
    requestBody: {
      content: {
        'application/json': components['schemas']['ratingSchema'];
      };
    };
    responses: {
      /** @description The current rating value for the rule */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ratingSchema'];
        };
      };
      /** @description The current rating value for the rule */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ratingSchema'];
        };
      };
      /** @description Invalid request, usually caused when some rule identifier doesn't exist */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRecommendations: {
    parameters: {
      query?: {
        /** @description If param is missing, endpoint will return all available rules including those that don't hit any clusters at the moment. If set to true, only returns impacting rules. If false, only returns those that aren't impacting. */
        impacting?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Returns a list recommendations and the number of clusters they're currently impacting. Default behaviour is to return only the rules that affect atleast one cluster. This can be changed by passing impacting parameter */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['recommendationListResponse'];
        };
      };
    };
  };
  getContentAndGroupsForRule: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description ID of the rule for which content is required.
         * @example some.python.module|ERROR_KEY_NAME
         */
        ruleId: components['parameters']['ruleId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A JSON object with the content. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            content?: {
              /** @description The title of the rule, a short description. */
              description?: string;
              /**
               * @description Whether the rule has been disabled/acked for all clusters or not.
               * @example false
               */
              disabled?: boolean;
              /** @description More specific, cluster-independent description of the rule */
              generic?: string;
              hosts_acked_count?: number;
              /**
               * @description How much of an impact this rule has on a cluster.
               * @enum {integer}
               */
              impact?: PathsRuleRuleIdGetResponses200ContentApplicationJsonContentImpact;
              /**
               * @description How likely is this rule to hit.
               * @enum {integer}
               */
              likelihood?: PathsRuleRuleIdGetResponses200ContentApplicationJsonContentLikelihood;
              more_info?: string;
              /**
               * Format: date-time
               * @description The date the rule was published. 'Added at' field in UI
               */
              publish_date?: string;
              /**
               * @description User vote - value of user voting. -1 is dislike vote, 0 is no vote, 1 is like vote.
               * @enum {integer}
               */
              rating?: PathsRuleRuleIdGetResponses200ContentApplicationJsonContentRating;
              /** @description Reason for the issue, giving the user more accurate description of the cause. */
              reason?: string;
              /** @description Resolution steps of the issue, possibly linking to a resolution article in the knowledge base. */
              resolution?: string;
              /**
               * @description Indicates the impact of the resolution steps on the cluster and other associated risks. Behaves in the same way as total_risk, 0 is returned when the rule doesn't have a resolution_risk defined.
               * @enum {integer}
               */
              resolution_risk?: PathsRuleRuleIdGetResponses200ContentApplicationJsonContentResolution_risk;
              rule_id?: string;
              /** @description List of tags that the rule contains */
              tags?: string[];
              /**
               * @description Total risk - calculated from rule impact and likelihood.
               * @enum {integer}
               */
              total_risk?: PathsRuleRuleIdGetResponses200ContentApplicationJsonContentTotal_risk;
            };
            groups?: {
              description?: string;
              tags?: string[];
              title?: string;
            }[];
            status?: components['schemas']['statusResponse'];
          };
        };
      };
      /** @description Rule ID is not available */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @example Item not found in the storage */
            status?: string;
          };
        };
      };
      /** @description Content service or aggregator service is unavailable. Specified in the status field. */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @example Item not found in the storage */
            status?: string;
          };
        };
      };
    };
  };
  getContentForRule: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description ID of the rule for which content is required.
         * @example some.python.module|ERROR_KEY_NAME
         */
        ruleId: components['parameters']['ruleId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A JSON object with the content. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            content?: {
              /** @description The title of the rule, a short description. */
              description?: string;
              /** @description More specific, cluster-independent description of the rule */
              generic?: string;
              /**
               * @description How much of an impact this rule has on a cluster.
               * @enum {integer}
               */
              impact?: PathsRuleRuleIdContentGetResponses200ContentApplicationJsonContentImpact;
              /**
               * @description How likely is this rule to hit.
               * @enum {integer}
               */
              likelihood?: PathsRuleRuleIdContentGetResponses200ContentApplicationJsonContentLikelihood;
              more_info?: string;
              /**
               * Format: date-time
               * @description The date the rule was published. 'Added at' field in UI
               */
              publish_date?: string;
              /** @description Reason for the issue, giving the user more accurate description of the cause. */
              reason?: string;
              /** @description Resolution steps of the issue, possibly linking to a resolution article in the knowledge base. */
              resolution?: string;
              rule_id?: string;
              /** @description List of tags that the rule contains */
              tags?: string[];
              /**
               * @description Total risk - calculated from rule impact and likelihood.
               * @enum {integer}
               */
              total_risk?: PathsRuleRuleIdContentGetResponses200ContentApplicationJsonContentTotal_risk;
            };
            groups?: {
              description?: string;
              tags?: string[];
              title?: string;
            }[];
            status?: components['schemas']['statusResponse'];
          };
        };
      };
      /** @description Rule ID is not available */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @example Item not found in the storage */
            status?: string;
          };
        };
      };
      /** @description Content service is unavailable. */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @example Item not found in the storage */
            status?: string;
          };
        };
      };
    };
  };
  getClustersForRecommendation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description Recommendation identifier, in the plugin_name|error_key format
         * @example existing.plugin.name|ERROR_KEY
         */
        rule_selector: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of cluster data for provided rule */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: {
              /** @description A list of clusters for which the user has disabled this rule */
              disabled?: {
                /** Format: uuid */
                cluster_id?: string;
                /**
                 * @description An human-readable name for the cluster
                 * @example Production cluster 1
                 */
                cluster_name?: string;
                /** Format: date-time */
                disabled_at?: string;
                /**
                 * @description User given justification why rule was disabled.
                 * @example Not useful for us.
                 */
                justification?: string;
              }[];
              /** @description A list of clusters, which are hitting this rule and are enabled. */
              enabled?: {
                /** Format: uuid */
                cluster?: string;
                /**
                 * @description An human-readable name for the cluster
                 * @example Production cluster 1
                 */
                cluster_name?: string;
                /**
                 * Format: date-time
                 * @description [Optional] Timestamp of the rule first started hitting
                 */
                impacted?: string;
                /**
                 * Format: date-time
                 * @description [Optional] Timestamp of the last analysis
                 */
                last_checked_at?: string;
                meta?: {
                  /**
                   * @description Version of OpenShift in the cluster
                   * @example 4.7
                   */
                  cluster_version?: string;
                };
              }[];
            };
            status?: components['schemas']['statusResponse'];
          };
        };
      };
      /** @description Request body could not be parsed, so the query is not processed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found, usually caused when some rule selector, organization or user doesn't exist */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error, should only be returned if unexpected error happened when querying from the DB */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getUpgradeRisksPredictionForClustersPost: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description List of cluster IDs. Each ID must conform to UUID format. */
    requestBody: {
      content: {
        /** @example {"clusters": ["34c3ecc5-624a-49a5-bab8-4fdc5e51a266"]} */
        'application/json': {
          clusters?: components['schemas']['clusterId'][];
        };
      };
    };
    responses: {
      /** @description Latest available update prediction for the given list of cluster IDs. Returns status of the prediction and their predictor facts that were taken into account for each cluster. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            predictions?: components['schemas']['upgradeRisksPrediction'][];
            status?: components['schemas']['statusResponse'];
          };
        };
      };
      /** @description Invalid request, usually caused when some cluster belongs to different organization. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
export enum PathsContentGetResponses200ContentApplicationJsonContentError_keysMetadataLikelihood {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum PathsContentGetResponses200ContentApplicationJsonContentError_keysTotal_risk {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum PathsNamespacesDvoNamespaceIdClusterClusterIdGetResponses200ContentApplicationJsonRecommendationsTotal_risk {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum PathsRuleRuleIdGetResponses200ContentApplicationJsonContentImpact {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum PathsRuleRuleIdGetResponses200ContentApplicationJsonContentLikelihood {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum PathsRuleRuleIdGetResponses200ContentApplicationJsonContentRating {
  ValueMinus1 = '-1',
  Value0 = '0',
  Value1 = '1',
}
export enum PathsRuleRuleIdGetResponses200ContentApplicationJsonContentResolution_risk {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum PathsRuleRuleIdGetResponses200ContentApplicationJsonContentTotal_risk {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum PathsRuleRuleIdContentGetResponses200ContentApplicationJsonContentImpact {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum PathsRuleRuleIdContentGetResponses200ContentApplicationJsonContentLikelihood {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum PathsRuleRuleIdContentGetResponses200ContentApplicationJsonContentTotal_risk {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum RecommendationListImpact {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum RecommendationListLikelihood {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum RecommendationListResolution_risk {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum RecommendationListTotal_risk {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum ReportDataTotal_risk {
  Value0 = 0,
  Value1 = 1,
  Value2 = 2,
  Value3 = 3,
  Value4 = 4,
}
export enum ReportDataUser_vote {
  ValueMinus1 = '-1',
  Value0 = '0',
  Value1 = '1',
}
