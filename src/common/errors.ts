import { AxiosError, AxiosResponse } from 'axios';

import { ExcessResource } from '~/types/accounts_mgmt.v1';
import { Error as CMSError } from '~/types/clusters_mgmt.v1';
import { ErrorDetail, ErrorState } from '~/types/types';

import { clustersConstants } from '../redux/constants';

const BANNED_USER_CODE = 'ACCT-MGMT-22';
const TERMS_REQUIRED_CODE = 'CLUSTERS-MGMT-451';

const overrideErrorMessage = (
  payload: Partial<CMSError & ErrorState>,
  actionType?: string,
): string => {
  if (!payload) {
    return '';
  }

  let message = '';

  // override error by its kind
  const errorKind =
    (payload?.details?.[0] as { kind: string })?.kind || payload?.errorDetails?.[0]?.kind;
  switch (errorKind) {
    case 'ExcessResources': {
      let resource = 'cluster';
      if (actionType !== undefined && /CLUSTER_ADDON/.test(actionType)) {
        resource = 'cluster add-on';
      }
      const verb =
        resource === 'cluster' &&
        actionType !== undefined &&
        actionType.includes(clustersConstants.EDIT_CLUSTER)
          ? 'edit'
          : 'create';
      message = `You are not authorized to ${verb} the ${resource} because your request exceeds available quota.
              In order to fulfill this request, you will need quota/subscriptions for:`;
      break;
    }
    default:
  }

  // override error by its code
  const errorCode = payload?.code;
  switch (errorCode) {
    case BANNED_USER_CODE: // ErrorBanned
      message = `Your account has been placed on Export Hold based on export control screening.
The Export Compliance Team has been notified that your account is on hold, and must conduct additional due diligence to resolve the Export Hold.
Try again in 24-48 hours.
Learn more: https://access.redhat.com/articles/1340183`;
      break;
    default:
  }

  return message;
};

const getErrorMessage = (action: { type?: string; payload?: AxiosError<any> }): string => {
  if (typeof action.payload?.response === 'undefined') {
    // Handle edge cases in which `payload` might be an Error type
    return String(action.payload);
  }

  const response = action.payload.response.data;

  // Determine if error needs to be overridden
  const message = overrideErrorMessage(response, action.type);
  if (message) {
    return message;
  }

  // CMS uses "kind" for the error object, but AMS uses 'type'
  if (response?.kind === 'Error' || response?.type === 'Error') {
    return `${response.code}:\n${response.reason}`;
  }

  return JSON.stringify(response);
};

/**
 * hasOwnErrorPage returns true is the api error has its won error page,
 * and it can be presented by ApiError.
 * @param {*} response The error response.
 */
const hasOwnErrorPage = (response: AxiosResponse) => response?.data?.code === TERMS_REQUIRED_CODE;

const getInternalErrorCode = (response: AxiosResponse): string | undefined => response?.data?.code;

/**
 * getErrorState returns the standard error state for a rejected redux action.
 * @param {*} action An action result object generated by redux-promise-middleware
 */
const getErrorState = (action: {
  type?: string;
  error?: boolean;
  payload?: AxiosError<any>;
}): ErrorState | { pending: false; fulfilled: false; error: false } =>
  action.payload?.response && hasOwnErrorPage(action.payload?.response)
    ? {
        // drop this error if already handled by its own error page.
        fulfilled: false,
        pending: false,
        error: false,
      }
    : {
        fulfilled: false,
        pending: false,
        error: true,
        errorCode: action.payload?.response?.status,
        internalErrorCode: action.payload?.response
          ? getInternalErrorCode(action.payload?.response)
          : undefined,
        errorMessage: getErrorMessage(action),
        errorDetails: action.payload?.response?.data?.details,
        operationID: action.payload?.response?.data?.operation_id,
      };

const isExcessResourcesErrorDetail = (
  e: ErrorDetail,
): e is {
  kind: 'ExcessResources';
  items?: ExcessResource[];
} => e.kind === 'ExcessResources';

const formatErrorDetails = (errorDetails?: ErrorDetail[]): Array<string | Array<string>> => {
  const formattedErrors: Array<string | Array<string>> = [];

  if (!errorDetails || !errorDetails.length) {
    return [];
  }

  errorDetails.forEach((details) => {
    if (isExcessResourcesErrorDetail(details)) {
      // Resource map: singular and plural
      const resourceMap: { [key: string]: string[] } = {
        addon: ['addon', 'addons'],
        'cluster.aws': ['cluster', 'clusters'],
        'cluster.gcp': ['cluster', 'clusters'],
        'compute.node.aws': ['node', 'nodes'],
        'compute.node.gcp': ['node', 'nodes'],
        'pv.storage.aws': ['GiB of storage', 'GiB of storage'],
        'pv.storage.gcp': ['GiB of storage', 'GiB of storage'],
        'network.loadbalancer.aws': ['load balancers', 'load balancers'],
        'network-gcp.loadbalancer.gcp': ['load balancers', 'load balancers'],
      };

      const getName = (type: string, count: number | undefined) => {
        if (resourceMap[type]) {
          return resourceMap[type][count === 1 ? 0 : 1];
        }
        return type;
      };

      // Add extra error details
      if (details.items) {
        formattedErrors.push(
          details.items.map((excessResource) => {
            if (excessResource.resource_type === 'addon') {
              return `${excessResource.resource_type}: ${excessResource.resource_name}`;
            }
            if (excessResource.resource_type && resourceMap[excessResource.resource_type]) {
              return `${excessResource.count} additional
                  ${getName(excessResource.resource_type, excessResource.count)} of type
                  ${excessResource.availability_zone_type} availability zone, instance size
                  ${excessResource.resource_name}.`;
            }
            return 'An error occurred';
          }),
        );
      } else {
        formattedErrors.push('Unknown resource');
      }
    } else if (
      details?.items &&
      ['AddOnParameterOptionList', 'AddOnRequirementData'].includes(details.kind)
    ) {
      formattedErrors.push(JSON.stringify(details.items, undefined, 2));
    } else if (Array.isArray(details?.items)) {
      // for arbitrary arrays of items, fallback to serializing each item
      formattedErrors.push(details.items.map((item) => JSON.stringify(item, undefined, 2)));
    }
  });

  return formattedErrors;
};

export {
  getInternalErrorCode,
  getErrorState,
  formatErrorDetails,
  hasOwnErrorPage,
  getErrorMessage,
  overrideErrorMessage,
  BANNED_USER_CODE,
  TERMS_REQUIRED_CODE,
};
